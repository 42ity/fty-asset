#### bios_asset_server - Server translating legacy configure messages to new protocl

bios_asset_server - Asset server, that takes care about distribution of
                                  asset information across the system

 ASSET PROTOCOL
 ## Topology request

 ------------------------------------------------------------------------
 power topology request:
     subject: "TOPOLOGY"
     message: is a multipart message A/B
             A = "TOPOLOGY_POWER" - mandatory
             B = "asset_name" - mandatory

 power topology reply in "OK" case:
     subject: "TOPOLOGY"
     message: is a multipart message A/B/D/C1/.../CN
             A = "TOPOLOGY_POWER" - mandatory
             B = "asset_name" - mandatory
             D = "OK" - mandatory
             Ci = "asset_name" of power source - not mandatory
                 if there are no power devices
                  -> message is A/B/D

 power topology reply in "ERROR" case:
     subject: "TOPOLOGY"
     message: is a multipart message A/B/D/E
             A = "TOPOLOGY_POWER" - mandatory
             B = "asset_name" - mandatory
             D = "ERROR" - mandatory
             E = "ASSET_NOT_FOUND"/"INTERNAL_ERROR" - mandatory

 ------------------------------------------------------------------------

## ASSET protocol
REQ:
    subject: "ASSET"
    Message is a multipart string message:

    * GET/<asset name>/<asset attribute 1>/.../<asset attribute N>

    where:
        <asset name>         = Name identifying the requested asset
 (OPTIONAL) <asset attributes X> = Request only attribute X.
                               None specified requests all asset attributes.

REP:
    subject: "ASSET"
    Message is a multipart message:

    * OK/[zhash_pack:hash]
    * ERROR/<reason>

    where:
        [zhash_pack:hash] = Frame with encoded zhash containing the values
        <reason>          = Error message/code

 ------------------------------------------------------------------------
## ASSETS in container
REQ:
    subject: "ASSETS_IN_CONTAINER"
    Message is a multipart string message

    * GET/<container name>/<type 1>/.../<type n>

    where:
        <container name>        = Name of the container things belongs to that
        <type X>                = Type or subtype to be returned. Possible values are
                                  ups
                                  TODO: add more
                                  when empty, no filtering is done
REP:
    subject: "ASSETS_IN_CONTAINER"
    Message is a multipart message:

    * OK                         = empty container
    * OK/<asset 1>/.../<asset N> = non-empty
    * ERROR/<reason>

    where:
        <reason>          = ASSET_NOT_FOUND / INTERNAL_ERROR / BAD_COMMAND


This is the class interface:

    //  Asset server, that takes care about distribution of
    //                                      asset information across the system
    AGENT_ASSET_EXPORT void
        bios_asset_server (zsock_t *pipe, void *args);
    
    //  Self test of this class
    AGENT_ASSET_EXPORT void
        bios_asset_server_test (bool verbose);

This is the class self test code:

    static const char* endpoint = "inproc://fty_asset_server-test";
    
    // malamute broker
    zactor_t *server = zactor_new (mlm_server, (void*) "Malamute");
    assert ( server != NULL );
    if (verbose) {
        zstr_send (server, "VERBOSE");
    }
    
    zstr_sendx (server, "BIND", endpoint, NULL);
    
    // NOT legacy assets
    zactor_t *la_server = zactor_new (bios_asset_server, (void*)"AGENT_ASSET");
    if (verbose) {
        zstr_send (la_server, "VERBOSE");
    }
    zstr_sendx (la_server, "CONNECT", endpoint, NULL);
    zsock_wait (la_server);
    
    mlm_client_t *client = mlm_client_new ();
    mlm_client_connect (client, endpoint, 5000, "topology-peer");
    // scenario name
    std::string scenario;
    // all topology messages has the same subject
    
    /*
    static const char* subject = "TOPOLOGY";
    
    // ====================================================
    scenario = "scenario 1";
    zsys_info ("# %s:", scenario.c_str());
    //      prepare and send request message
    zmsg_t *msg = zmsg_new();
    zmsg_addstr (msg, "TOPOLOGY_POWER");
    zmsg_addstr (msg, "RACK1-LAB");
    mlm_client_sendto (client, "AGENT_ASSET", subject, NULL, 5000, &msg);
    
    //      wait for a responce from asset agent
    zpoller_t *poller = zpoller_new (mlm_client_msgpipe(client), NULL);
    void *which = zpoller_wait (poller, 1000);
    assert ( which != NULL );
    zpoller_destroy (&poller);
    
    //      receive a responce
    msg = mlm_client_recv (client);
    
    //      check the response
    assert ( zmsg_size (msg) == 5 );
    std::vector <std::string> expectedMessageGeneral =
        {"TOPOLOGY_POWER", "RACK1-LAB", "OK"};
    for ( int i = 0 ; i < 3 ; i++ ) {
        char *somestring = zmsg_popstr (msg);
        assert ( expectedMessageGeneral.at(i) == somestring );
        free (somestring);
    }
    std::set <std::string> expectedMessageDevices =
        {"UPS1-LAB", "UPS2-LAB"};
    for ( int i = 3 ; i < 5 ; i++ ) {
        char *somestring = zmsg_popstr (msg);
        assert ( expectedMessageDevices.count(somestring) == 1 );
        free (somestring);
    }
    //       crear
    zmsg_destroy (&msg);
    expectedMessageGeneral.clear();
    zsys_info ("### %s: OK", scenario.c_str());
    
    
    // ====================================================
    scenario = "scenario 2";
    zsys_info ("# %s:", scenario.c_str());
    //      prepare and send request message
    msg = zmsg_new();
    zmsg_addstr (msg, "TOPOLOGY_POWER");
    zmsg_addstr (msg, "NOTFOUNDASSET");
    mlm_client_sendto (client, "AGENT_ASSET", subject, NULL, 5000, &msg);
    
    //      wait for a responce from asset agent
    poller = zpoller_new (mlm_client_msgpipe(client), NULL);
    which = zpoller_wait (poller, 1000);
    assert ( which != NULL );
    zpoller_destroy (&poller);
    
    //      receive a responce
    msg = mlm_client_recv (client);
    //      check the response
    assert ( zmsg_size (msg) == 4 );
    expectedMessageGeneral =
        {"TOPOLOGY_POWER", "NOTFOUNDASSET", "ERROR", "ASSET_NOT_FOUND"};
    for ( int i = 0 ; i < 4 ; i++ ) {
        char *somestring = zmsg_popstr (msg);
        assert ( expectedMessageGeneral.at(i) == somestring );
        free (somestring);
    }
    
    //       crear
    zmsg_destroy (&msg);
    expectedMessageGeneral.clear();
    zsys_info ("### %s: OK", scenario.c_str());
    */
    
    // commented out - test doesnt work
    // // scenario3 ASSETS_IN_CONTAINER
    // mlm_client_sendtox (client, "AGENT_ASSET", "ASSETS_IN_CONTAINER", "GET", "DC007", NULL);
    
    // char *recv_subject, *reply, *reason;
    // mlm_client_recvx (client, &recv_subject, &reply, &reason, NULL);
    
    // assert (streq (recv_subject, "ASSETS_IN_CONTAINER"));
    // assert (streq (reply, "ERROR"));
    // assert (streq (reason, "INTERNAL_ERROR"));
    
    // zstr_free (&recv_subject);
    // zstr_free (&reply);
    // zstr_free (&reason);
    
    // selftest should clear after itself
    mlm_client_destroy (&client);
    zactor_destroy (&la_server);
    
    zactor_destroy (&server);
    

